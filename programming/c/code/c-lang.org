#+Title: The C Programming Language
#+OPTIONS: ^:nil num:nil author:nil email:nil creator:nil timestamp:nil

* Chapter 1 - A Tutorial Introduction

** hello.c

- =$ gcc hello.c=
- =./a.out=

#+BEGIN_SRC c :tangle hello.c
  #include <stdio.h>

  main()
  {
      printf("hello, world\n");
  }
#+END_SRC

** The first C program hello world

- =$ gcc hello2.c=
- =./a.out=

#+BEGIN_SRC c :tangle hello2.c
  #include <stdio.h>

  main()
  {
      printf("hello, world\n");
  }
#+END_SRC

- include information about standard library
- define a function called =main= that received no argument values
- statements of =main= are enclosed in braces
- main calls library function =printf= to print this sequence of
  characters =\n= represents the newline character

** hello world

- =$ gcc hello3.c=
- =./a.out=

#+BEGIN_SRC c :tangle hello3.c
  #include <stdio.h>

  main()
  {
      printf("hello, ");
      printf("world");
      printf("\n");
  }
#+END_SRC

** fahrenheit-celsius

- =$ gcc fc1.c=
- =./a.out=

#+BEGIN_SRC c :tangle fc1.c
  #include <stdio.h>

  /* print Fahrenheit-Celsius table for fahr = 0, 20, ..., 300 */

  main()
  {
      int fahr, celsius;
      int lower, upper, step;

      lower = 0;                  /* lower limit of temperature scale */
      upper = 300;                /* upper limit */
      step = 20;                  /* step size */

      fahr = lower;
      while (fahr <= upper) {
          celsius = 5 * (fahr - 32) / 9;
          printf("%d\t%d\n", fahr, celsius);
          fahr = fahr + step;
      }
  }
#+END_SRC

** fahrenheit-celsius floating point

- =$ gcc fc2.c=
- =./a.out=

#+BEGIN_SRC c :tangle fc2.c
  #include <stdio.h>

  /* print Fahrenheit-Celsius table for fahr = 0, 20, ..., 300;
     floating-point version */

  main()
  {
      float fahr, celsius;
      float lower, upper, step;

      lower = 0;                  /* lower limit of temperature scale */
      upper = 300;                /* upper limit */
      step = 20;                  /* step size */

      fahr = lower;
      while (fahr <= upper) {
          celsius = (5.0 / 9.0) * (fahr - 32.0);
          printf("%3.0f %6.1f\n", fahr, celsius);
          fahr = fahr + step;
      }
  }
#+END_SRC

** fahrenheit-celsius table (in one go?)

#+BEGIN_SRC c :tangle fc3.c
  #include <stdio.h>

  /* print Fahrenheit-Celsius table */
  main()
  {
      int fahr;

      for (fahr = 0; fahr <= 300; fahr = fahr + 20)
          printf("%3d %6.1f\n", fahr, (5.0 / 9.0) * (fahr - 32));
  }

#+END_SRC

** fahrenheit-celsius constants

- =$ gcc fc4.c=
- =./a.out=

#+BEGIN_SRC c :tangle fc4.c
  #include <stdio.h>

  #define LOWER  0                /* lower limit of table */
  #define UPPER  300              /* upper limit */
  #define STEP   20               /* step size */

  /* print Fahrenheit-Celsius table */
  main()
  {
      int fahr;

      for (fahr = LOWER; fahr <= UPPER; fahr = fahr + STEP)
          printf("%3d %6.1f\n", fahr, (5.0 / 9.0) * (fahr - 32));
  }
#+END_SRC

** file copy

- =$ gcc filecopy1.c=
- =./a.out=
- enter characters
- C-d to terminate

#+BEGIN_SRC c :tangle filecopy1.c
  #include <stdio.h>

  /* copy input to output; 1st version */
  main()
  {
      int c;

      c = getchar();
      while (c != EOF) {
          putchar(c);
          c = getchar();
      }
  }
#+END_SRC

** file copy 2

- =$ gcc filecopy2.c=
- =./a.out=

#+BEGIN_SRC c :tangle filecopy2.c
  #include <stdio.h>

  /* copy input to output; 2nd version */
  main()
  {
      int c;

      while ((c = getchar()) != EOF)
          putchar(c);
  }
#+END_SRC

** count chars 1

- =$ gcc countchars1.c=
- =./a.out=
- RET C-d to get number of characters. but get extra
- includes newlines in count?

#+BEGIN_SRC c :tangle countchars1.c
  #include <stdio.h>

  /* count characters in input; 1st version */
  main()
  {
      long nc;

      nc = 0;
      while (getchar() != EOF)
          ++nc;
      printf("%ld\n", nc);
  }
#+END_SRC

** count chars 2

- =$ gcc countchars2.c=
- =./a.out=

#+BEGIN_SRC c :tangle countchars2.c
  #include <stdio.h>

  /* count characters in input; 2nd version */
  main()
  {
      double nc;

      for (nc = 0; getchar() != EOF; ++nc);
      printf("%.0f\n", nc);
  }
#+END_SRC

** count lines

- =$ gcc countlines.c=
- =./a.out=
- C-d to get result

#+BEGIN_SRC c :tangle countlines.c
  #include <stdio.h>

  /* count lines in input */
  main()
  {
      int c, nl;

      nl = 0;
      while ((c = getchar()) != EOF)
          if (c == '\n')
              ++nl;
      printf("%d\n", nl);
  }
#+END_SRC

** word counting

- =$ gcc wordcount.c=
- =./a.out=

#+BEGIN_SRC c :tangle wordcount.c
  #include <stdio.h>

  #define IN   1                  /* inside a word */
  #define OUT  0                  /* outside a word */

  /* count lines, words, and characters in input */

  main()
  {
      int c, nl, nw, nc, state;

      state = OUT;
      nl = nw = nc = 0;
      while ((c = getchar()) != EOF) {
          ++nc;
          if (c == '\n')
              ++nl;
          if (c == ' ' || c == '\n' || c == '\t')
              state = OUT;
          else if (state == OUT) {
              state = IN;
              ++nw;
          }
      }
      printf("%d %d %d\n", nl, nw, nc);
  }
#+END_SRC

** arrays

- =$ gcc arrays.c=
- =./a.out=

#+BEGIN_SRC c :tangle arrays.c
  #include <stdio.h>

  /* count digits, white space, others */
  main()
  {
      int c, i, nwhite, nother;
      int ndigit[10];

      nwhite = nother = 0;
      for (i = 0; i < 10; ++i)
          ndigit[i] = 0;

      while ((c = getchar()) != EOF)
          if (c >= '0' && c <= '9')
              ++ndigit[c - '0'];
          else if (c == ' ' || c == '\n' || c == '\t')
              ++nwhite;
          else
              ++nother;

      printf("digits =");
      for (i = 0; i < 10; ++i)
          printf(" %d", ndigit[i]);
      printf(", white space = %d, other = %d\n", nwhite, nother);
  }
#+END_SRC

#+BEGIN_EXAMPLE
  $ ./a.out
  1       2       12 3
  digits = 0 2 2 1 0 0 0 0 0 0, white space = 4, other = 0
#+END_EXAMPLE

** functions

- =$ gcc functions.c=
- =./a.out=

#+BEGIN_SRC c :tangle functions.c
  #include <stdio.h>

  int power(int m, int n);

  /* test power function */
  main()
  {
      int i;

      for (i = 0; i < 10; ++i)
          printf("%d %d %d\n", i, power(2, i), power(-3, i));
      return 0;
  }

  /* power: raise base to n-th power; n >= 0 */
  int power(int base, int n)
  {
      int i, p;

      p = 1;
      for (i = 1; i <= n; ++i)
          p = p * base;
      return p;
  }
#+END_SRC

#+BEGIN_EXAMPLE
  $ ./a.out
  0 1 1
  1 2 -3
  2 4 9
  3 8 -27
  4 16 81
  5 32 -243
  6 64 729
  7 128 -2187
  8 256 6561
  9 512 -19683
#+END_EXAMPLE

** character arrays

- =$ gcc characterarrays.c=
- =./a.out=
- ; need to change the name of the getline function. conflict
- this just prints the longest line entered
- changed the variables in the function prototype but this wasn't necessary

#+BEGIN_SRC c :tangle characterarrays.c

  #include <stdio.h>
  #define MAXLINE 1000            /* maximum input line length */

  int xgetline(char s1[], int lim1);
  void copy(char to[], char from[]);

  /* print the longest input line */
  main()
  {
      int len;                    /* current line length */
      int max;                    /* maximum length seen so far */
      char line[MAXLINE];         /* current input line */
      char longest[MAXLINE];      /* longest line saved here */

      max = 0;
      while ((len = xgetline(line, MAXLINE)) > 0)
          if (len > max) {
              max = len;
              copy(longest, line);
          }
      if (max > 0)                /* there was a line */
          printf("%s", longest);
      return 0;
  }

  /* getline: read a line into s, return length */
  int xgetline(char s[], int lim)
  {
      int c, i;

      for (i = 0; i < lim - 1 && (c = getchar()) != EOF && c != '\n'; ++i)
          s[i] = c;
      if (c == '\n') {
          s[i] = c;
          ++i;
      }
      s[i] = '\0';
      return i;
  }

  /* copy: copy 'from' into 'to'; assume to is big enough */
  void copy(char to[], char from[])
  {
      int i;

      i = 0;
      while ((to[i] = from[i]) != '\0')
          ++i;
  }
#+END_SRC

** external variables and scope

- $ gcc scope.c
- ./a.out
- had to rename the getline() function
- change getchar to getchar()

#+BEGIN_SRC c :tangle scope.c
  #include <stdio.h>

  #define MAXLINE 1000            /* maximum input line size */

  int max;                        /* maximum length seen so far */
  char line[MAXLINE];             /* current input line */
  char longest[MAXLINE];          /* longest line saved here */

  int xgetline(void);
  void copy(void);

  /* print longest input line; specialized version */
  main()
  {
      int len;
      extern int max;
      extern char longest[];

      max = 0;
      while ((len = xgetline()) > 0)
          if (len > max) {
              max = len;
              copy();
          }
      if (max > 0)                /* there was a line */
          printf("%s", longest);
      return 0;
  }

  /* getline: specialized version */
  int xgetline(void)
  {
      int c, i;
      extern char line[];

      for (i = 0; i < MAXLINE - 1 && (c = getchar()) != EOF && c != '\n'; ++i)
          line[i] = c;
      if (c == '\n') {
          line[i] = c;
          ++i;
      }
      line[i] = '\0';
      return i;
  }

  /* copy: specialized version */
  void copy(void)
  {
      int i;
      extern char line[], longest[];

      i = 0;
      while ((longest[i] = line[i]) != '\0')
          ++i;
  }
#+END_SRC

* Chapter 2 - Types, Operators and Expressions

** function: strlen

- change strlen to xstrlen. conflict
- gcc strlen.c
- custom main

#+BEGIN_SRC c :tangle strlen.c
  #include <stdio.h>

  /* strlen: return length of s */
  int xstrlen(char s[])
  {
      int i;
      while (s[i] != '\0')
          ++i;
      return i;
  }

  main()
  {
      int xx = xstrlen("house");

      printf("%d\n", xx);

  }
#+END_SRC

** function: atoi

- ascii to integer
- not sure what is happening

#+BEGIN_SRC c :tangle atoi.c
  #include <stdio.h>

  /* atoi: convert s to integer */
  int atoi(char s[])
  {
      int i, n;

      n = 0;
      for (i = 0; s[i] >= '0' && s[i] <= '9'; ++i)
          n = 10 * n + (s[i] - '0');
      return n;
  }

  int main()
  {
      int xx;

      xx = atoi("88");
      printf("%d\n", xx);

  }
#+END_SRC

** function: lower

#+BEGIN_SRC c :tangle lower.c
  #include <stdio.h>

  /* lower: convert c to lower case; ASCII only */
  int lower(int c)
  {
      if (c >= 'A' && c <= 'Z')
          return c + 'a' - 'A';
      else
          return c;
  }

  int main()
  {
      char yy = 'Z';
      int xx;

      xx = lower(yy);
      printf("%d", xx);
  }
#+END_SRC

** function: rand

#+BEGIN_SRC c :tangle rand.c
  #include <stdio.h>

  unsigned long int next = 1;
  /* rand: return pseudo-random integer on 0..32767 */
  int rand(void)
  {
      next = next * 1103515245 + 12345;
      return (unsigned int) (next / 65536) % 32768;
  }

  /* srand: set seed for rand() */
  void srand(unsigned int seed)
  {
      next = seed;
  }

  int main()
  {
      int xx, i;

      for (i = 0; i < 10; i++) {
          srand(i);

          xx = rand();
          printf("%d\n", xx);
      }

  }
#+END_SRC

** function: squeeze

- ascii automatically converted to integers?
- this works but i don't understand how

#+BEGIN_SRC c :tangle squeeze.c

  /* squeeze: delete all c from s */
  void squeeze(char s[], int c)
  {
      int i, j;

      for (i = j = 0; s[i] != '\0'; i++)
          if (s[i] != c)
              s[j++] = s[i];
      s[j] = '\0';
  }

  int main()
  {
      char s[] = "house";
      int c = 'o';                // o is 111
      squeeze(s, c);
  }
#+END_SRC

** function: strcat

- this only copies the first character of c
- had to rename strcat to xstrcat

#+BEGIN_SRC c :tangle strcat.c
  /* strcat: concatenate t to end of s; s must be big enough */
  void xstrcat(char s[], char t[])
  {
      int i, j;

      i = j = 0;
      while (s[i] != '\0')        /* find end of s */
          i++;
      while ((s[i++] = t[j++]) != '\0')   /* copy t */
          ;
  }

  int main()
  {
      char n[] = "new";
      char c[] = "car";
      xstrcat(n, c);
  }
#+END_SRC

** function: getbits

- doesn't work like it should

#+BEGIN_SRC c :tangle getbits.c
  #include <stdio.h>

  /* getbits: get n bits from position p */
  unsigned getbits(unsigned x, int p, int n)
  {
      return (x >> (p + 1 - n)) & ~(~0 << n);
  }

  int main()
  {
      unsigned ff;
      unsigned x = 4;

      ff = getbits(x, 8, 4);
      printf("%d", ff);
  }
#+END_SRC

** function: bitcount

- haven't looked at this

#+BEGIN_SRC c :tangle bitcount.c
  /* bitcount: count 1 bits in x */
  int bitcount(unsigned x)
  {
      int b;

      for (b = 0; x != 0; x >>= 1)
          if (x & 01)
              b++;
      return b;
  }
#+END_SRC

* Chapter 3 - Control Flow

** function: binsearch

#+BEGIN_SRC c :tangle binsearch.c
  /* binsearch: find x in v[0] <= v[1] <= ... <= v[n-1] */
  int binsearch(int x, int v[], int n)
  {
      int low, high, mid;

      low = 0;
      high = n - 1;
      while (low <= high) {
          mid = (low + high) / 2;
          if (x < v[mid])
              high = mid + 1;
          else if (x > v[mid])
              low = mid + 1;
          else                    /* found match */
              return mid;
      }
      return -1;                  /* no match */
  }
#+END_SRC

** program: count digits, white space, others (switch)

#+BEGIN_SRC c :tangle switchex.c
  #include <stdio.h>

  /* count digits, white space, others */
  main()
  {
      int c, i, nwhite, nother, ndigit[10];

      nwhite = nother = 0;
      for (i = 0; i < 10; i++)
          ndigit[i] = 0;
      while ((c = getchar()) != EOF) {
          switch (c) {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
              ndigit[c - '0']++;
              break;
          case ' ':
          case '\n':
          case '\t':
              nwhite++;
              break;
          default:
              nother++;
              break;
          }
      }
      printf("digits =");
      for (i = 0; i < 10; i++)
          printf(" %d", ndigit[i]);
      printf(", white space = %d, other = %d\n", nwhite, nother);
      return 0;
  }
#+END_SRC

#+BEGIN_EXAMPLE
  $ ./a.out
  123 45
  digits = 0 1 1 1 1 1 0 0 0 0, white space = 2, other = 0
#+END_EXAMPLE

** function: atoi

#+BEGIN_SRC c :tangle atoif.c
  #include <ctype.h>

  /* atoi: convert s to integer; version 2 */
  int atoi(char s[])
  {
      int i, n, sign;

      for (i = 0; isspace(s[i]); i++);    /* skip white space */
      sign = (s[i] == '-') ? -1 : 1;
      if (s[i] == '+' || s[i] == '-')     /* skip sign */
          i++;
      for (n = 0; isdigit(s[i]); i++)
          n = 10 * n + (s[i] - '0');
      return sign * n;
  }
#+END_SRC

** function: shellsort

#+BEGIN_SRC c :tangle shellsort.c
  /* shellsort: sort v[0]...v[n-1] into increasing order */
  void shellsort(int v[], int n)
  {
      int gap, i, j, temp;
      for (gap = n / 2; gap > 0; gap /= 2)
          for (i = gap; i < n; i++)
              for (j = i - gap; j >= 0 && v[j] > v[j + gap]; j -= gap) {
                  temp = v[j];
                  v[j] = v[j + gap];
                  v[j + gap] = temp;
              }
  }
#+END_SRC

** function: reverse

#+BEGIN_SRC c :tangle reverse.c
  #include <string.h>

  /* reverse: reverse string s in place */
  void reverse(char s[])
  {
      int c, i, j;

      for (i = 0, j = strlen(s) - 1; i < j; i++, j--) {
          c = s[i];
          s[i] = s[j];
          s[j] = c;
      }
  }
#+END_SRC

** function: itoa

#+BEGIN_SRC c :tangle itoa.c
  /* itoa: convert n to characters in s */
  void itoa(int n, char s[])
  {
      int i, sign;

      if ((sign = n) < 0)         /* record sign */
          n = -n;                 /* make n positive */
      i = 0;
      do {                        /* generate digits in reverse order */
          s[i++] = n % 10 + '0';  /* get next digit */
      } while ((n /= 10) > 0);    /* delete it */
      if (sign < 0)
          s[i++] = '-';
      s[i] = '\0';
      reverse(s);
  }
#+END_SRC

** function: trim

#+BEGIN_SRC c :tangle trim.c
  /* trim: remove trailing blanks, tabs, newlines */
  int trim(char s[])
  {
      int n;
      for (n = strlen(s) - 1; n >= 0; n--)
          if (s[n] != ' ' && s[n] != '\t' && s[n] != '\n')
              break;
      s[n + 1] = '\0';
      return n;
  }
#+END_SRC

* Chapter 4 - Functions and Program Structure

** program: find all lines matching pattern

#+BEGIN_EXAMPLE
  41 ; not sure what this does
#+END_EXAMPLE

#+BEGIN_SRC c :tangle 41.c
  #include <stdio.h>

  #define MAXLINE 1000            /* maximum input line length */

  int xgetline(char line[], int max);
  int strindex(char source[], char searchfor[]);

  char pattern[] = "ould";        /* pattern to search for */

  /* find all lines matching pattern */
  main()
  {
      char line[MAXLINE];
      int found = 0;

      while (xgetline(line, MAXLINE) > 0)
          if (strindex(line, pattern) >= 0) {
              printf("%s", line);
              found++;
          }
      return found;
  }

  /* getline: get line into s, return length */
  int xgetline(char s[], int lim)
  {
      int c, i;

      i = 0;
      while (--lim > 0 && (c = getchar()) != EOF && c != '\n')
          s[i++] = c;
      if (c == '\n')
          s[i++] = c;
      s[i] = '\0';
      return i;
  }

  /* strindex: return index of t in s, -1 if none */
  int strindex(char s[], char t[])
  {
      int i, j, k;

      for (i = 0; s[i] != '\0'; i++) {
          for (j = i, k = 0; t[k] != '\0' && s[j] == t[k]; j++, k++);
          if (k > 0 && t[k] == '\0')
              return i;
      }
      return -1;
  }
#+END_SRC

** function: atof

#+BEGIN_EXAMPLE
  ascii to float
#+END_EXAMPLE

#+BEGIN_SRC c :tangle atof.c
  #include <ctype.h>

  /* atof: convert string s to double */
  double atof(char s[])
  {
      double val, power;
      int i, sign;

      for (i = 0; isspace(s[i]); i++);    /* skip white space */
      sign = (s[i] == '-') ? -1 : 1;
      if (s[i] == '+' || s[i] == '-')
          i++;
      for (val = 0.0; isdigit(s[i]); i++)
          val = 10.0 * val + (s[i] - '0');
      if (s[i] == '.')
          i++;
      for (power = 1.0; isdigit(s[i]); i++) {
          val = 10.0 * val + (s[i] - '0');
          power *= 10;
      }
      return sign * val / power;
  }
#+END_SRC

** program: calculator

need to include and change getline

#+BEGIN_SRC c :tangle calculator.c
  #include <stdio.h>

  #define MAXLINE 100

  /* rudimentary calculator */
  main()
  {
      double sum, atof(char[]);
      char line[MAXLINE];
      int getline(char line[], int max);

      sum = 0;
      while (getline(line, MAXLINE) > 0)
          printf("\t%g\n", sum += atof(line));
      return 0;
  }
#+END_SRC

** function: atoi (rewrite)

#+BEGIN_EXAMPLE
  ascii to integer
#+END_EXAMPLE

Given atof, properly declared, we could write atoi (convert a string
to int) in terms of it:

#+BEGIN_SRC c :tangle atoir.c
  /* atoi: convert string s to integer using atof */
  int atoi(char s[])
  {
    double atof(char s[]);
    return (int) atof(s);
  }
#+END_SRC

** program: reverse polish calculator

push and pop?

#+BEGIN_SRC c :tangle rpn.c
  #include <stdio.h>
  #include <stdlib.h>     /* for atof() */

  #define MAXOP 100       /* max size of operand or operator */
  #define NUMBER '0'      /* signal that a number was found */

  int getop(char []);
  void push(double);
  double pop(void);

  /* reverse Polish calculator */
  main()
  {
    int type;
    double op2;
    char s[MAXOP];

    while ((type = getop(s)) != EOF) {
      switch (type) {
      case NUMBER:
        push(atof(s));
        break;
      case '+':
        push(pop() + pop());
        break;
      case '*':
        push(pop() * pop());
        break;
      case '-':
        op2 = pop();
        push(pop() - op2);
        break;
      case '/':
        op2 = pop();
        if (op2 != 0.0)
          push(pop() / op2);
        else
          printf("error: zero divisor\n");
        break;
      case '\n':
        printf("\t%.8g\n", pop());
        break;
      default:
        printf("error: unknown command %s\n", s);
        break;
      }
    }
    return 0;
  }
#+END_SRC

** functions: push & pop

#+BEGIN_SRC c
  #define MAXVAL 100 /* maximum depth of val stack */

  int sp = 0; /* next free stack position */
  double val[MAXVAL]; /* value stack */

  /* push: push f onto value stack */
  void push(double f)
  {
    if (sp < MAXVAL)
      val[sp++] = f;
    else
      printf("error: stack full, can't push %g\n", f);
  }

  /* pop: pop and return top value from stack */
  double pop(void)
  {
    if (sp > 0)
      return val[--sp];
    else {
      printf("error: stack empty\n");
      return 0.0;
    }
  }
#+END_SRC

** program: complete cal

missing getopt()

#+BEGIN_SRC c :tangle rpn1.c
  #include <stdio.h>
  #include <stdlib.h>     /* for atof() */

  #define MAXOP 100       /* max size of operand or operator */
  #define NUMBER '0'      /* signal that a number was found */

  int getop(char []);
  void push(double);
  double pop(void);

  /* reverse Polish calculator */
  main()
  {
    int type;
    double op2;
    char s[MAXOP];

    while ((type = getop(s)) != EOF) {
      switch (type) {
      case NUMBER:
        push(atof(s));
        break;
      case '+':
        push(pop() + pop());
        break;
      case '*':
        push(pop() * pop());
        break;
      case '-':
        op2 = pop();
        push(pop() - op2);
        break;
      case '/':
        op2 = pop();
        if (op2 != 0.0)
          push(pop() / op2);
        else
          printf("error: zero divisor\n");
        break;
      case '\n':
        printf("\t%.8g\n", pop());
        break;
      default:
        printf("error: unknown command %s\n", s);
        break;
      }
    }
    return 0;
  }

  #define MAXVAL 100 /* maximum depth of val stack */

  int sp = 0; /* next free stack position */
  double val[MAXVAL]; /* value stack */

  /* push: push f onto value stack */
  void push(double f)
  {
    if (sp < MAXVAL)
      val[sp++] = f;
    else
      printf("error: stack full, can't push %g\n", f);
  }

  /* pop: pop and return top value from stack */
  double pop(void)
  {
    if (sp > 0)
      return val[--sp];
    else {
      printf("error: stack empty\n");
      return 0.0;
    }
  }

  #include <ctype.h>

  int getch(void);
  void ungetch(int);

  /* getop: get next character or numeric operand */
  int getop(char s[])
  {
    int i, c;
    while ((s[0] = c = getch()) == ' ' || c == '\t')
      ;
    s[1] = '\0';
    if (!isdigit(c) && c != '.')
      return c; /* not a number */
    i = 0;
    if (isdigit(c)) /* collect integer part */
      while (isdigit(s[++i] = c = getch()))
        ;
    if (c == '.') /* collect fraction part */
      while (isdigit(s[++i] = c = getch()))
        ;
    s[i] = '\0';
    if (c != EOF)
      ungetch(c);
    return NUMBER;
  }

  #define BUFSIZE 100

  char buf[BUFSIZE];      /* buffer for ungetch */
  int bufp = 0;           /* next free position in buf */

  int getch(void) /* get a (possibly pushed-back) character */
  {
    return (bufp > 0) ? buf[--bufp] : getchar();
  }

  void ungetch(int c) /* push character back on input */
  {
    if (bufp >= BUFSIZE)
      printf("ungetch: too many characters\n");
    else
      buf[bufp++] = c;
  }
#+END_SRC

** function: getop

#+BEGIN_SRC c
  #include <ctype.h>

  int getch(void);
  void ungetch(int);

  /* getop: get next character or numeric operand */
  int getop(char s[])
  {
    int i, c;
    while ((s[0] = c = getch()) == ' ' || c == '\t')
      ;
    s[1] = '\0';
    if (!isdigit(c) && c != '.')
      return c; /* not a number */
    i = 0;
    if (isdigit(c)) /* collect integer part */
      while (isdigit(s[++i] = c = getch()))
        ;
    if (c == '.') /* collect fraction part */
      while (isdigit(s[++i] = c = getch()))
        ;
    s[i] = '\0';
    if (c != EOF)
      ungetch(c);
    return NUMBER;
  }
#+END_SRC

** funcions: getch & ungetch

#+BEGIN_SRC c
  #define BUFSIZE 100

  char buf[BUFSIZE];      /* buffer for ungetch */
  int bufp = 0;           /* next free position in buf */

  int getch(void) /* get a (possibly pushed-back) character */
  {
    return (bufp > 0) ? buf[--bufp] : getchar();
  }

  void ungetch(int c) /* push character back on input */
  {
    if (bufp >= BUFSIZE)
      printf("ungetch: too many characters\n");
    else
      buf[bufp++] = c;
  }
#+END_SRC

** function: printd (recursion example)

#+BEGIN_EXAMPLE
  print decimal
#+END_EXAMPLE

#+BEGIN_SRC c
  #include <stdio.h>

  /* printd: print n in decimal */
  void printd(int n)
  {
    if (n < 0) {
      putchar('-');
      n = -n;
    }
    if (n / 10)
      printd(n / 10);
    putchar(n % 10 + '0');
  }
#+END_SRC

** functions: qsort & swap

#+BEGIN_SRC c :tangle qsort.c
  /* qsort: sort v[left]...v[right] into increasing order */
  void qsort(int v[], int left, int right)
  {
      int i, last;
      void swap(int v[], int i, int j);

      if (left >= right)          /* do nothing if array contains */
          return;                 /* fewer than two elements */
      swap(v, left, (left + right) / 2);  /* move partition elem */
      last = left;                /* to v[0] */
      for (i = left + 1; i <= right; i++) /* partition */
          if (v[i] < v[left])
              swap(v, ++last, i);
      swap(v, left, last);        /* restore partition elem */
      qsort(v, left, last - 1);
      qsort(v, last + 1, right);
  }
#+END_SRC

#+BEGIN_SRC c :tangle swap.c
  /* swap: interchange v[i] and v[j] */
  void swap(int v[], int i, int j)
  {
      int temp;

      temp = v[i];
      v[i] = v[j];
      v[j] = temp;
  }
#+END_SRC

* Chapter 5 - Pointers and Arrays

** function: swap (with pointers)

#+BEGIN_SRC c
  void swap(int *px, int *py) /* interchange *px and *py */
  {
    int temp;

    temp = *px;
    ,*px = *py;
    ,*py = temp;
  }
#+END_SRC

** function: getint

#+BEGIN_SRC c :tangle getint.c
  #include <ctype.h>

  int getch(void);
  void ungetch(int);

  /* getint: get next integer from input into *pn */
  int getint(int *pn)
  {
    int c, sign;

    while (isspace(c = getch())) /* skip white space */
      ;
    if (!isdigit(c) && c != EOF && c != '+' && c != '-') {
      ungetch(c); /* it is not a number */
      return 0;
    }
    sign = (c == '-') ? -1 : 1;
    if (c == '+' || c == '-')
      c = getch();
    for (*pn = 0; isdigit(c), c = getch())
      ,*pn = 10 * *pn + (c - '0');
    ,*pn *= sign;
    if (c != EOF)
      ungetch(c);
    return c;
  }
#+END_SRC

** function: strlen

#+BEGIN_SRC c
  /* strlen: return length of string s */
  int strlen(char *s)
  {
    int n;

    for (n = 0; *s != '\0', s++)
      n++;
    return n;
  }
#+END_SRC

** functions: alloc & afree

#+BEGIN_SRC c
  #define ALLOCSIZE 10000 /* size of available space */

  static char allocbuf[ALLOCSIZE]; /* storage for alloc */
  static char *allocp = allocbuf; /* next free position */

  char *alloc(int n) /* return pointer to n characters */
  {
    if (allocbuf + ALLOCSIZE - allocp >= n) { /* it fits */
      allocp += n;
      return allocp - n; /* old p */
    } else /* not enough room */
      return 0;
  }

  void afree(char *p) /* free storage pointed to by p */
  {
    if (p >= allocbuf && p < allocbuf + ALLOCSIZE)
      allocp = p;
  }
#+END_SRC

** function: strlen

#+BEGIN_SRC c
  /* strlen: return length of string s */
  int strlen(char *s)
  {
    char *p = s;

    while (*p != '\0')
      p++;
    return p - s;
  }
#+END_SRC

** function: strcpy (using arrays)

#+BEGIN_SRC c
  /* strcpy: copy t to s; array subscript version */
  void strcpy(char *s, char *t)
  {
    int i;

    i = 0;
    while ((s[i] = t[i]) != '\0')
      i++;
  }
#+END_SRC

** function: strcpy (using pointers)

#+BEGIN_SRC c
  /* strcpy: copy t to s; pointer version */
  void strcpy(char *s, char *t)
  {
    int i;

    i = 0;
    while ((*s = *t) != '\0') {
      s++;
      t++;
    }
  }
#+END_SRC

** function: strcpy (experienced programmers)

#+BEGIN_SRC c
  /* strcpy: copy t to s; pointer version 2 */
  void strcpy(char *s, char *t)
  {
    while ((*s++ = *t++) != '\0')
      ;
  }
#+END_SRC

** function: strcpy (v3)

#+BEGIN_SRC c
  /* strcpy: copy t to s; pointer version 3 */
  void strcpy(char *s, char *t)
  {
    while (*s++ = *t++)
      ;
  }
#+END_SRC

** function: strcmp (no pointers)

#+BEGIN_SRC c
  /* strcmp: return <0 if s<t, 0 if s==t, >0 if s>t */
  int strcmp(char *s, char *t)
  {
    int i;

    for (i = 0; s[i] == t[i]; i++)
      if (s[i] == '\0')
        return 0;
    return s[i] - t[i];
  }
#+END_SRC

** function: strcmp (with pointers)

#+BEGIN_SRC c
  /* strcmp: return <0 if s<t, 0 if s==t, >0 if s>t */
  int strcmp(char *s, char *t)
  {
    for ( ; *s == *t; s++, t++)
      if (*s == '\0')
        return 0;
    return *s - *t;
  }
#+END_SRC

** program: sort input lines

#+BEGIN_EXAMPLE
  + readlines and writelines

  The function getline is from Section 1.9.

  55.c:39:33: error: lvalue required as left operand of assignment
      if (nlines >= maxlines || p = alloc(len) == NULL)
#+END_EXAMPLE

#+BEGIN_SRC c :tangle 55.c
  #include <stdio.h>
  #include <string.h>

  #define MAXLINES 5000 /* max #lines to be sorted */
  char *lineptr[MAXLINES]; /* pointers to text lines */

  int readlines(char *lineptr[], int nlines);
  void writelines(char *lineptr[], int nlines);
  void qsort(char *lineptr[], int left, int right);

  /* sort input lines */
  main()
  {
    int nlines; /* number of input lines read */

    if ((nlines = readlines(lineptr, MAXLINES)) >= 0) {
      qsort(lineptr, 0, nlines-1);
      writelines(lineptr, nlines);
      return 0;
    } else {
      printf("error: input too big to sort\n");
      return 1;
    }
  }

  #define MAXLEN 1000 /* max length of any input line */
  int getline(char *, int);
  char *alloc(int);

  /* readlines: read input lines */
  int readlines(char *lineptr[], int maxlines)
  {
    int len, nlines;
    char *p, line[MAXLEN];

    nlines = 0;
    while ((len = getline(line, MAXLEN)) > 0)
      if (nlines >= maxlines || p == alloc(len) == NULL)
        return -1;
      else {
        line[len-1] = '\0'; /* delete newline */
        strcpy(p, line);
        lineptr[nlines++] = p;
      }
    return nlines;
  }

  /* writelines: write output lines */
  void writelines(char *lineptr[], int nlines)
  {
    int i;

    for (i = 0; i < nlines; i++)
      printf("%s\n", lineptr[i]);
  }
#+END_SRC

** function: writelines

#+BEGIN_SRC c
  /* writelines: write output lines */
  void writelines(char *lineptr[], int nlines)
  {
    while (nlines-- > 0)
      printf("%s\n", *lineptr++);
  }
#+END_SRC

** function: qsort

#+BEGIN_SRC c
  /* qsort: sort v[left]...v[right] into increasing order */
  void qsort(char *v[], int left, int right)
  {
    int i, last;
    void swap(char *v[], int i, int j);

    if (left >= right) /* do nothing if array contains */
      return;          /* fewer than two elements */
    swap(v, left, (left + right)/2);
    last = left;
    for (i = left+1; i <= right; i++)
      if (strcmp(v[i], v[left]) < 0)
        swap(v, ++last, i);
    swap(v, left, last);
    qsort(v, left, last-1);
    qsort(v, last+1, right);
  }
#+END_SRC

** function: swap (using char*)

#+BEGIN_SRC c
  /* swap: interchange v[i] and v[j] */
  void swap(char *v[], int i, int j)
  {
    char *temp;

    temp = v[i];
    v[i] = v[j];
    v[j] = temp;
  }
#+END_SRC

** multi-dimensional array: daytab, functions: day_of_year & month_day

#+BEGIN_SRC c
  static char daytab[2][13] = {
    {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
    {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
  };

  /* day_of_year: set day of year from month & day */
  int day_of_year(int year, int month, int day)
  {
    int i, leap;
    leap = year%4 == 0 && year%100 != 0 || year%400 == 0;
    for (i = 1; i < month; i++)
      day += daytab[leap][i];
    return day;
  }

  /* month_day: set month, day from day of year */
  void month_day(int year, int yearday, int *pmonth, int *pday)
  {
    int i, leap;

    leap = year%4 == 0 && year%100 != 0 || year%400 == 0;
    for (i = 1; yearday > daytab[leap][i]; i++)
      yearday -= daytab[leap][i];
    ,*pmonth = i;
    ,*pday = yearday;
  }
#+END_SRC

** function: month_name

#+BEGIN_SRC c
  /* month_name: return name of n-th month */
  char *month_name(int n)
  {
    static char *name[] = {
      "Illegal month",
      "January", "February", "March",
      "April", "May", "June",
      "July", "August", "September",
      "October", "November", "December"
    };

    return (n < 1 || n > 12) ? name[0] : name[n];
  }
#+END_SRC

** program: krecho v1

#+BEGIN_EXAMPLE
  kr echo
#+END_EXAMPLE

#+BEGIN_SRC c :tangle krecho.c
  #include <stdio.h>

  /* echo command-line arguments; 1st version */
  main(int argc, char *argv[])
  {
    int i;

    for (i = 1; i < argc; i++)
      printf("%s%s", argv[i], (i < argc-1) ? " " : "");
    printf("\n");
    return 0;
  }
#+END_SRC

** program: krecho v2

#+BEGIN_EXAMPLE
  kr echo
#+END_EXAMPLE

#+BEGIN_SRC c :tangle krechov2.c
  #include <stdio.h>

  /* echo command-line arguments; 2nd version */
  main(int argc, char *argv[])
  {
    while (--argc > 0)
      printf("%s%s", *++argv, (argc > 1) ? " " : "");
    printf("\n");
    return 0;
  }
#+END_SRC

=printf((argc > 1) ? "%s " : "%s", *++argv);=

Alternatively, we could write the printf statement as

This shows that the format argument of printf can be an expression too.

** program: main

uses getline

#+BEGIN_SRC c :tangle
  #include <stdio.h>
  #include <string.h>
  #define MAXLINE 1000

  int getline(char *line, int max);

  /* find: print lines that match pattern from 1st arg */
  main(int argc, char *argv[])
  {
    char line[MAXLINE];
    int found = 0;

    if (argc != 2)
      printf("Usage: find pattern\n");
    else
      while (getline(line, MAXLINE) > 0)
        if (strstr(line, argv[1]) != NULL) {
          printf("%s", line);
          found++;
        }
    return found;
  }
#+END_SRC

** program: find: print lines that match pattern from 1st arg

#+BEGIN_SRC c
  #include <stdio.h>
  #include <string.h>
  #define MAXLINE 1000

  int getline(char *line, int max);

  /* find: print lines that match pattern from 1st arg */
  main(int argc, char *argv[])
  {
    char line[MAXLINE];
    long lineno = 0;
    int c, except = 0, number = 0, found = 0;

    while (--argc > 0 && (*++argv)[0] == '-')
      while (c = *++argv[0])
        switch (c) {
        case 'x':
          except = 1;
          break;
        case 'n':
          number = 1;
          break;
        default:
          printf("find: illegal option %c\n", c);
          argc = 0;
          found = -1;
          break;
        }
    if (argc != 1)
      printf("Usage: find -x -n pattern\n");
    else
      while (getline(line, MAXLINE) > 0) {
        lineno++;
        if ((strstr(line, *argv) != NULL) != except) {
          if (number)
            printf("%ld:", lineno);
          printf("%s", line);
          found++;
        }
      }
    return found;
  }
#+END_SRC

** program: sort input lines

#+BEGIN_SRC c
  #include <stdio.h>
  #include <string.h>

  #define MAXLINES 5000 /* max #lines to be sorted */
  char *lineptr[MAXLINES]; /* pointers to text lines */


  int readlines(char *lineptr[], int nlines);
  void writelines(char *lineptr[], int nlines);

  void qsort(void *lineptr[], int left, int right,
             int (*comp)(void *, void *));
  int numcmp(char *, char *);

  /* sort input lines */
  main(int argc, char *argv[])
  {
    int nlines; /* number of input lines read */
    int numeric = 0; /* 1 if numeric sort */

    if (argc > 1 && strcmp(argv[1], "-n") == 0)
      numeric = 1;
    if ((nlines = readlines(lineptr, MAXLINES)) >= 0) {
      qsort((void**) lineptr, 0, nlines-1,
            (int (*)(void*,void*))(numeric ? numcmp : strcmp));
      writelines(lineptr, nlines);
      return 0;
    } else {
      printf("input too big to sort\n");
      return 1;
    }
  }
#+END_SRC

** function: qsort

#+BEGIN_SRC c
  /* qsort: sort v[left]...v[right] into increasing order */
  void qsort(void *v[], int left, int right,
             int (*comp)(void *, void *))
  {
    int i, last;
    void swap(void *v[], int, int);

    if (left >= right) /* do nothing if array contains */
      return;          /* fewer than two elements */
    swap(v, left, (left + right)/2);
    last = left;
    for (i = left+1; i <= right; i++)
      if ((*comp)(v[i], v[left]) < 0)
        swap(v, ++last, i);
    swap(v, left, last);
    qsort(v, left, last-1, comp);
    qsort(v, last+1, right, comp);
  }
#+END_SRC

** function: numcmp

#+BEGIN_SRC c
  #include <stdlib.h>

  /* numcmp: compare s1 and s2 numerically */
  int numcmp(char *s1, char *s2)
  {
    double v1, v2;

    v1 = atof(s1);
    v2 = atof(s2);
    if (v1 < v2)
      return -1;
    else if (v1 > v2)
      return 1;
    else
      return 0;
  }
#+END_SRC

** function: swap (using void*)

#+BEGIN_SRC c
  void swap(void *v[], int i, int j;)
  {
    void *temp;

    temp = v[i];
    v[i] = v[j];
    v[j] = temp;
  }
#+END_SRC

** functions: dcl & dirdcl

#+BEGIN_EXAMPLE
  recursive decent parser
#+END_EXAMPLE

#+BEGIN_SRC c
  /* dcl: parse a declarator */
  void dcl(void)
  {
    int ns;

    for (ns = 0; gettoken() == '*'; ) /* count *'s */
      ns++;
    dirdcl();
    while (ns-- > 0)
      strcat(out, " pointer to");
  }

  /* dirdcl: parse a direct declarator */
  void dirdcl(void)
  {
    int type;

    if (tokentype == '(') { /* ( dcl ) */
      dcl();
      if (tokentype != ')')
        printf("error: missing )\n");
    } else if (tokentype == NAME) /* variable name */
      strcpy(name, token);
    else
      printf("error: expected name or (dcl)\n");
    while ((type=gettoken()) == PARENS || type == BRACKETS)
      if (type == PARENS)
        strcat(out, " function returning");
      else {
        strcat(out, " array");
        strcat(out, token);
        strcat(out, " of");
      }
  }
#+END_SRC

** program: convert declaration to words

#+BEGIN_SRC c :tangle 56.c
  #include <stdio.h>
  #include <string.h>
  #include <ctype.h>
  #include "krbook.h"

  #define MAXTOKEN 100

  enum { NAME, PARENS, BRACKETS };

  void dcl(void);
  void dirdcl(void);

  int gettoken(void);
  int tokentype;             /* type of last token */
  char token[MAXTOKEN];      /* last token string */
  char name[MAXTOKEN];       /* identifier name */
  char datatype[MAXTOKEN];   /* data type = char, int, etc. */
  char out[1000];

  main() /* convert declaration to words */
  {
    while (gettoken() != EOF) { /* 1st token on line */
      strcpy(datatype, token); /* is the datatype */
      out[0] = '\0';
      dcl(); /* parse rest of line */
      if (tokentype != '\n')
        printf("syntax error\n");
      printf("%s: %s %s\n", name, out, datatype);
    }
    return 0;
  }
#+END_SRC

** function: gettoken

think that i'm missing some global variables

#+BEGIN_SRC c :tangle krbook.h
  int gettoken(void) /* return next token */
  {
    int c, getch(void);
    void ungetch(int);
    char *p = token;

    while ((c = getch()) == ' ' || c == '\t')
      ;
    if (c == '(') {
      if ((c = getch()) == ')') {
        strcpy(token, "()");
        return tokentype = PARENS;
      } else {
        ungetch(c);
        return tokentype = '(';
      }
    } else if (c == '[') {
      for (*p++ = c; (*p++ = getch()) != ']'; )
        ;
      ,*p = '\0';
      return tokentype = BRACKETS;
    } else if (isalpha(c)) {
      for (*p++ = c; isalnum(c = getch()); )
        ,*p++ = c;
      ,*p = '\0';
      ungetch(c);
      return tokentype = NAME;
    } else
      return tokentype = c;
  }
#+END_SRC

** program: undcl

#+BEGIN_SRC c
  /* undcl: convert word descriptions to declarations */
  main()
  {
    int type;
    char temp[MAXTOKEN];

    while (gettoken() != EOF) {
      strcpy(out, token);
      while ((type = gettoken()) != '\n')
        if (type == PARENS || type == BRACKETS)
          strcat(out, token);
        else if (type == '*') {
          sprintf(temp, "(*%s)", out);
          strcpy(out, temp);
        } else if (type == NAME) {
          sprintf(temp, "%s %s", token, out);
          strcpy(out, temp);
        } else
          printf("invalid input at %s\n", token);
    }
    return 0;
  }
#+END_SRC

* Chapter 6 - Structures

** function: makepoint

#+BEGIN_SRC c
  /* makepoint: make a point from x and y components */
  struct point makepoint(int x, int y)
  {
    struct point temp;

    temp.x = x;
    temp.y = y;
    return temp;
  }
#+END_SRC

** program: using makepoint

#+BEGIN_SRC c
  #include <stdio.h>

  #define XMAX 80
  #define YMAX 24

  struct point {
    int x;
    int y;
  };

  struct rect {
    struct point pt1;
    struct point pt2;
  };

  int main(void) {
    struct rect screen;
    struct point middle;
    struct point makepoint(int, int);

    screen.pt1 = makepoint(0,0);
    screen.pt2 = makepoint(XMAX, YMAX);
    middle = makepoint((screen.pt1.x + screen.pt2.x)/2,
                       (screen.pt1.y + screen.pt2.y)/2);

    printf("x:%d y:%d\n",middle.x, middle.y);

    return 0;
  }
#+END_SRC

** function: addpoint

#+BEGIN_SRC c
  /* addpoints: add two points */
  struct point addpoint(struct point p1, struct point p2)
  {
    p1.x += p2.x;
    p1.y += p2.y;
    return p1;
  }
#+END_SRC

** function: ptinrect

#+BEGIN_SRC c
  /* ptinrect: return 1 if p in r, 0 if not */
  int ptinrect(struct point p, struct rect r)
  {
    return p.x >= r.pt1.x && p.x < r.pt2.x
      && p.y >= r.pt1.y && p.y < r.pt2.y;
  }
#+END_SRC

** function: canonrect

#+BEGIN_SRC c
  #define min(a, b) ((a) < (b) ? (a) : (b))
  #define max(a, b) ((a) > (b) ? (a) : (b))

  /* canonrect: canonicalize coordinates of rectangle */
  struct rect canonrect(struct rect r)
  {
    struct rect temp;

    temp.pt1.x = min(r.pt1.x,r.pt2.x);
    temp.pt1.y = min(r.pt1.y,r.pt2.y);
    temp.pt2.x = max(r.pt1.x,r.pt2.x);
    temp.pt2.y = max(r.pt1.y,r.pt2.y);
    return temp;
  }
#+END_SRC

** program: keyword-counting (using array indices)

#+BEGIN_EXAMPLE
  won't compile
  keytab?
#+END_EXAMPLE

#+BEGIN_SRC c :tangle krsearch.c
  #include <stdio.h>
  #include <ctype.h>
  #include <string.h>

  #define MAXWORD 100
  #define NKEYS (sizeof keytab / sizeof(struct key))

  /* int getword(char *, int); */
  /* int binsearch(char *, struct key *, int); */

  /* declare and initialize structure */
  struct key {
    char *word;
    int count;
  } keytab[] = {
                "auto", 0,
                "break", 0,
                "case", 0,
                "char", 0,
                "const", 0,
                "continue", 0,
                "default", 0,
                "unsigned", 0,
                "void", 0,
                "volatile", 0,
                "while", 0
  };

  /* count C keywords */
  main()
  {
    int n;
    char word[MAXWORD];

    while (getword(word, MAXWORD) != EOF)
      if (isalpha(word[0]))
        if ((n = binsearch(word, keytab, NKEYS)) >= 0)
          keytab[n].count++;
    for (n = 0; n < NKEYS; n++)
      if (keytab[n].count > 0)
        printf("%4d %s\n",
               keytab[n].count, keytab[n].word);
    return 0;
  }

  /* binsearch: find word in tab[0]...tab[n-1] */
  int binsearch(char *word, struct key tab[], int n)
  {
    int cond;
    int low, high, mid;

    low = 0;
    high = n - 1;
    while (low <= high) {
      mid = (low+high) / 2;
      if ((cond = strcmp(word, tab[mid].word)) < 0)
        high = mid - 1;
      else if (cond > 0)
        low = mid + 1;
      else
        return mid;
    }
    return -1;
  }
#+END_SRC

** function: getword

#+BEGIN_SRC c :tangle ch06.h
  /* getword: get next word or character from input */
  int getword(char *word, int lim)
  {
    int c, getch(void);
    void ungetch(int);
    char *w = word;

    while (isspace(c = getch()))
      ;
    if (c != EOF)
      ,*w++ = c;
    if (!isalpha(c)) {
      ,*w = '\0';
      return c;
    }
    for ( ; --lim > 0; w++)
      if (!isalnum(*w = getch())) {
        ungetch(*w);
        break;
      }
    ,*w = '\0';
    return word[0];
  }
#+END_SRC

** program: keyword-counting (using pointers)

#+BEGIN_SRC c :tangle krpoint.c
  #include <stdio.h>
  #include <ctype.h>
  #include <string.h>
  #include "ch06.h"

  #define MAXWORD 100
  #define NKEYS (sizeof keytab / sizeof(struct key))

  int getword(char *, int);
  struct key *binsearch(char *, struct key *, int);

  struct key {
    char *word;
    int count;
  } keytab[] = {
                "auto", 0,
                "break", 0,
                "case", 0,
                "char", 0,
                "const", 0,
                "continue", 0,
                "default", 0,
                "unsigned", 0,
                "void", 0,
                "volatile", 0,
                "while", 0
  };

  /* count C keywords; pointer version */
  main()
  {
    char word[MAXWORD];
    struct key *p;

    while (getword(word, MAXWORD) != EOF)
      if (isalpha(word[0]))
        if ((p=binsearch(word, keytab, NKEYS)) != NULL)
          p->count++;
    for (p = keytab; p < keytab + NKEYS; p++)
      if (p->count > 0)
        printf("%4d %s\n", p->count, p->word);
    return 0;
  }

  /* binsearch: find word in tab[0]...tab[n-1] */
  struct key *binsearch(char *word, struct key *tab, int n)
  {
    int cond;
    struct key *low = &tab[0];
    struct key *high = &tab[n];
    struct key *mid;

    while (low < high) {
      mid = low + (high-low) / 2;
      if ((cond = strcmp(word, mid->word)) < 0)
        high = mid;
      else if (cond > 0)
        low = mid + 1;
      else
        return mid;
    }
    return NULL;
  }
#+END_SRC

** struct: tnode

#+BEGIN_SRC c :tangle ch06.h
  struct tnode {		/* the tree node: */
    char *word;		/* points to the text */
    int count;		/* number of occurrences */
    struct tnode *left;	/* left child */
    struct tnode *right;	/* right child */
  };
#+END_SRC

** program: word frequency count

#+BEGIN_SRC c :tangle kr nodes.c
  #include <stdio.h>
  #include <ctype.h>
  #include <string.h>
  #include "ch06.h"

  #define MAXWORD 100

  struct tnode *addtree(struct tnode *, char *);
  void treeprint(struct tnode *);
  int getword(char *, int);

  /* word frequency count */
  main()
  {
    struct tnode *root;
    char word[MAXWORD];

    root = NULL;
    while (getword(word, MAXWORD) != EOF)
      if (isalpha(word[0]))
        root = addtree(root, word);
    treeprint(root);
    return 0;
  }
#+END_SRC

** function: addtree

#+BEGIN_SRC c
  struct tnode *talloc(void);
  char *strdup(char *);

  /* addtree: add a node with w, at or below p */
  struct treenode *addtree(struct tnode *p, char *w)
  {
    int cond;
    if (p == NULL) { /* a new word has arrived */
      p = talloc();  /* make a new node */
      p->word = strdup(w);
      p->count = 1;
      p->left = p->right = NULL;
    } else if ((cond = strcmp(w, p->word)) == 0)
      p->count++; /* repeated word */
    else if (cond < 0) /* less than into left subtree */
      p->left = addtree(p->left, w);
    else /* greater than into right subtree */
      p->right = addtree(p->right, w);
    return p;
  }
#+END_SRC

** function: treeprint

#+BEGIN_SRC c :tangle ch06.h
  /* treeprint: in-order print of tree p */
  void treeprint(struct tnode *p)
  {
    if (p != NULL) {
      treeprint(p->left);
      printf("%4d %s\n", p->count, p->word);
      treeprint(p->right);
    }
  }
#+END_SRC

** functions: talloc & strdup

#+BEGIN_SRC c
  #include <stdlib.h>

  /* talloc: make a tnode */
  struct tnode *talloc(void)
  {
    return (struct tnode *) malloc(sizeof(struct tnode));
  }

  char *strdup(char *s) /* make a duplicate of s */
  {
    char *p;

    p = (char *) malloc(strlen(s)+1); /* +1 for '\0' */
    if (p != NULL)
      strcpy(p, s);
    return p;
  }
#+END_SRC

** struct: nlist

#+BEGIN_SRC c
  struct nlist {		/* table entry: */
    struct nlist *next;	/* next entry in chain */
    char *name;		/* defined name */
    char *defn;		/* replacement text */
  };
#+END_SRC

** function: hash

#+BEGIN_SRC c
  /* hash: form hash value for string s */
  unsigned hash(char *s)
  {
    unsigned hashval;
    for (hashval = 0; *s != '\0'; s++)
      hashval = *s + 31 * hashval;
    return hashval % HASHSIZE;
  }
#+END_SRC

** function: lookup

#+BEGIN_SRC c
  /* lookup: look for s in hashtab */
  struct nlist *lookup(char *s)
  {
    struct nlist *np;
    for (np = hashtab[hash(s)]; np != NULL; np = np->next)
      if (strcmp(s, np->name) == 0)
        return np; /* found */
    return NULL; /* not found */
  }
#+END_SRC

** function: install

#+BEGIN_SRC c
  struct nlist *lookup(char *);
  char *strdup(char *);

  /* install: put (name, defn) in hashtab */
  struct nlist *install(char *name, char *defn)
  {
    struct nlist *np;
    unsigned hashval;

    if ((np = lookup(name)) == NULL) { /* not found */
      np = (struct nlist *) malloc(sizeof(*np));
      if (np == NULL || (np->name = strdup(name)) == NULL)
        return NULL;
      hashval = hash(name);
      np->next = hashtab[hashval];
      hashtab[hashval] = np;
    } else /* already there */
      free((void *) np->defn); /*free previous defn */
    if ((np->defn = strdup(defn)) == NULL)
      return NULL;
    return np;
  }
#+END_SRC

** struct: tnode / Treenode

#+BEGIN_SRC c
  typedef struct tnode *Treeptr;

  typedef struct tnode {	/* the tree node: */
    char *word;		/* points to the text */
    int count;		/* number of occurrences */
    struct tnode *left;	/* left child */
    struct tnode *right;	/* right child */
  } Treenode;
#+END_SRC

** function: talloc

#+BEGIN_SRC c
  Treeptr talloc(void)
  {
    return (Treeptr) malloc(sizeof(Treenode));
  }
#+END_SRC

* Chapter 7 - Input and Output

** program: convert input to lower case

- =$ gcc lower.c=
- =./a.out=
- enter char(s) and RET

#+BEGIN_SRC c :tangle lower.c
  #include <stdio.h>
  #include <ctype.h>

  /* lower: convert input to lower case */
  main()
  {
      int c;

      while ((c = getchar()) != EOF)
          putchar(tolower(c));
      return 0;
  }
#+END_SRC

** program: ex printf myprint.c

printf("%.*s", max, s);

- how to assign a string of characters to a variable?
- define the max constant?
- note: * is followed by and =int=

#+BEGIN_SRC c :tangle myprint.c
  #include <stdio.h>

  #define max 12

  char s[max] = "hello, world";

  main()
  {
      printf("%.*s\n", max, s);
      printf("%s\n", s);          // %s
      printf("%10s\n", s);        // %10s
      printf("%.10s\n", s);       // %.10s
      printf("%-10s\n", s);       // %-10s
      printf("%.15s\n", s);       // %.15s
      printf("%-15s\n", s);       // %-15s
      printf("%15.10s\n", s);     // %15.10s
      printf("%-15.10s\n", s);    // %-15.10s
  }
#+END_SRC

output
#+BEGIN_EXAMPLE
  hello,.world
  hello,.world
  hello,.world
  hello,.wor
  hello,.world
  hello,.world
  hello,.world...
  .....hello,.wor
  hello,.wor
#+END_EXAMPLE

** program: minimal printf with variable argument list

#+BEGIN_SRC c :tangle minprintf.c
  #include <stdarg.h>
  #include <stdio.h>

  /* minprintf: minimal printf with variable argument list */
  void minprintf(char *fmt, ...)
  {
      va_list ap;                 /* points to each unnamed arg in turn */
      char *p, *sval;
      int ival;
      double dval;

      va_start(ap, fmt);          /* make ap point to 1st unnamed arg */
      for (p = fmt; *p; p++) {
          if (*p != '%') {
              putchar(*p);
              continue;
          }
          switch (*++p) {
          case 'd':
              ival = va_arg(ap, int);
              printf("%d", ival);
              break;
          case 'f':
              dval = va_arg(ap, double);
              printf("%f", dval);
              break;
          case 's':
              for (sval = va_arg(ap, char *); *sval; sval++)
                  putchar(*sval);
              break;
          default:
              putchar(*p);
              break;
          }
      }
      va_end(ap);                 /* clean up when done */
  }


  int main()
  {
       int xx = 7;
       char yy[] = "asdfasf";
       minprintf("%d\n",7);
       minprintf("%s\n",yy);
  }
#+END_SRC

** program: calculator

- calculates a running sum
- outputs numbers as float with percision 2.

#+BEGIN_SRC c :tangle krscan.c
  #include <stdio.h>

  main() /* rudimentary calculator */
  {
    double sum, v;

    sum = 0;
    while (scanf("%lf", &v) == 1)
      printf("\t%.2f\n", sum += v);
    return 0;
  }
#+END_SRC

** program: krcatv1

- works ok

#+BEGIN_SRC c :tangle krcat1.c
  #include <stdio.h>

  /* cat: concatenate files, version 1 */
  main(int argc, char *argv[])
  {
    FILE *fp;
    void filecopy(FILE *, FILE *);

      if (argc == 1) /* no args; copy standard input */
        filecopy(stdin, stdout);
      else
        while(--argc > 0)
          if ((fp = fopen(*++argv, "r")) == NULL) {
            printf("cat: can't open %s\n", *argv);
            return 1;
          } else {
            filecopy(fp, stdout);
            fclose(fp);
          }
    return 0;
  }

  /* filecopy: copy file ifp to file ofp */
  void filecopy(FILE *ifp, FILE *ofp)
  {
    int c;

    while ((c = getc(ifp)) != EOF)
      putc(c, ofp);
  }
#+END_SRC

** program: cat revised (error handling)

warnings about the exit

#+BEGIN_SRC c :tangle krcatv2.c
  #include <stdio.h>

  /* cat: concatenate files, version 2 */
  main(int argc, char *argv[])
  {
    FILE *fp;
    void filecopy(FILE *, FILE *);
    char *prog = argv[0]; /* program name for errors */

    if (argc == 1 ) /* no args; copy standard input */
      filecopy(stdin, stdout);
    else
      while (--argc > 0)
        if ((fp = fopen(*++argv, "r")) == NULL) {
          fprintf(stderr, "%s: can't open %s\n",
                  prog, *argv);
          exit(1);
        } else {
          filecopy(fp, stdout);
          fclose(fp);
        }
    if (ferror(stdout)) {
      fprintf(stderr, "%s: error writing stdout\n", prog);
      exit(2);
    }
    exit(0);
  }

  /* adding from previous program */

  /* filecopy: copy file ifp to file ofp */
  void filecopy(FILE *ifp, FILE *ofp)
  {
    int c;

    while ((c = getc(ifp)) != EOF)
      putc(c, ofp);
  }
#+END_SRC

** functions: fputs & fgets

#+BEGIN_SRC c :tangle fputsgets.c
  /* fgets: get at most n chars from iop */
  char *fgets(char *s, int n, FILE *iop)
  {
    register int c;
    register char *cs;

    cs = s;
    while (--n > 0 && (c = getc(iop)) != EOF)
      if ((*cs++ = c) == '\n')
        break;
    ,*cs = '\0';
    return (c == EOF && cs == s) ? NULL : s;
  }

  /* fputs: put string s on file iop */
  int fputs(char *s, FILE *iop)
  {
    int c;

    while (c = *s++)
      putc(c, iop);
    return ferror(iop) ? EOF : 0;
  }
#+END_SRC

** function: getline (using fgets)

#+BEGIN_SRC c :tangle fgets.c
  /* getline: read a line, return length */
  int getline(char *line, int max)
  {
    if (fgets(line, max, stdin) == NULL)
      return 0;
    else
      return strlen(line);
  }
#+END_SRC

* Chapter 8 - The UNIX System Interface
